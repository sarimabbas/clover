# Client

Since Clover routes are OpenAPI compliant, you can generate a client against the spec using any library of your choice e.g. [Orval](https://orval.dev/overview) or [oazapfts](https://github.com/oazapfts/oazapfts).

If you'd rather not add a generation step, Clover also provides a lightweight fetcher that can be used to make requests to the API.

```ts
// server.ts

import { makeRequestHandler } from "@sarim.garden/clover";

const { handler, clientConfig, openAPIPathsObject } = makeRequestHandler({
  input: z.object({
    name: z.string(),
  }),
  output: z.object({
    greeting: z.string(),
  }),
  run: async ({ request, input, sendOutput }) => {
    const { name } = input;
    return sendOutput({ greeting: `Hello, ${name}!` });
  },
  path: "/api/hello",
  method: "GET",
  description: "Greets the user",
  authenticate: async (req) => {
    return true;
  },
});

export type clientTypes = typeof clientConfig;
```

```ts
// client.ts

import { makeFetcher } from "@sarim.garden/clover";

export const fetcher = makeFetcher({
  baseUrl: "https://api.example.com",
  headers: {},
});
```

The fetcher is simply a typesafe wrapper around fetch that manages query params, path params, and request/response bodies. You can use the fetcher anywhere to make network requests to your API routes. The fetcher is generic; once you pass in the client types, you will get intellisense on all the fields.

```ts
// some/other/file.ts

import { fetcher } from "../../client";
import type { clientTypes } from "../../server";

const resp = fetcher<clientTypes>({
  input: {
    name: "Sarim",
  },
  method: "GET",
  path: "/api/hello",
});
```
